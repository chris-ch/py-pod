"""
Toolbox for handling projections onto linear varieties.

@author: Christophe Alexandre <ch.alexandre at bluewin dot ch>

@license:
Copyright(C) 2010 Christophe Alexandre

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/lgpl.txt>.
"""
import logging

import linalg
import util

_h = util.NullHandler()
_logger = logging.getLogger('vecspace')
_logger.addHandler(_h)

class VectorSpace(object):
  """
  Essentially a factory for geometrical objects.
  
  Joining an origin to a linear variety would create a VectorSpace.
  """  
  def __init__(self, dimension, basis=None):
    self.dimension = dimension
    self.origin = linalg.zero(dimension)
    
  def define_point(self, *coordinates):
    return linalg.Point(*coordinates)
    
  def define_line(self, p0):
    sl = StraightLine(p0)
    return sl

class StraightLine(object):
  """
  """
  
  def __init__(self, point):
    """
    """
    self.point = point
    
  def project(self, point):
    """
    Generalizing projection onto induced subspace.
    """
    subspace = VectorSubspace(self.point)
    proj = subspace.project(point.sub(self.point))
    proj.projected = proj.projected.add(self.point)
    return proj
    
  def __repr__(self):
    out = str(self.points) 
    return out

class VectorSubspace(object):
  """
  Defines a set on which we can project a point.
  """
  
  def __init__(self, point):
    """
    Defining a n-subspace generated by n points.
    """
    self.def_point = point

  def project(self, point):
    """
    The solution implies (x - x*) perpendicular to each y[i]
    with x* = sum( alpha[i] * y[i] )
    and y[i]: points generating the subspace.
    """
    space_dim = point.get_length()
    
    _logger.debug('space_dim: %s' % space_dim)
    
    m_value = self.def_point.product(self.def_point)
    
    b_value = point.product(self.def_point)
    
    alpha = b_value / m_value
    
    result = linalg.zero(space_dim)
    _logger.debug('result spaceholder: %s' % result)
    
    component = self.def_point.scale(alpha)
    result = result.add(component)
    
    return Projection(result, point)
    
class Projection(object):
  """
  Simple container gathering details about projection.
  """
  def __init__(self, projected, start):
    self.projected = projected
    self.start = start
    self.projector = projected.sub(start)
    
    
